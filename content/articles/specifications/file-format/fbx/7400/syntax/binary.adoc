---
title: "FBX 7.4/7.5 構文解説 (Binary)"
created_at: 2016-05-10T18:40:44+0900
excerpt: "FBX 7.4/7.5 のバイナリ仕様について解説。"
kind: article
htags:
  - "仕様解説/ファイル形式/FBX"
---

このページでは、__FBX Binary__の読み込みに必要な事項を解説する。

[[primitive-info-representation]]
== プリミティブな情報の表現
__FBX Binary__中では多バイトの整数や浮動小数点数を利用する場合、すべて**リトルエンディアン**である。
明示されたわけではないが、常識的に考えて符号付き整数は2の補数表現であろう。

[NOTE]
.埋め込まれたデータ中のエンディアン
言うまでもないが、バイナリデータとして埋め込まれているテクスチャ中の整数などはFBXフォーマットの支配下にないため、
そのエンディアンなどは画像のフォーマットによる。


また、整数型であっても、それが符号付きか符号無しか判然としない場合がある(たとえば32ビット整数で表現されているFBXのバージョン等)が、
この場合符号については明示せず単に「32ビット整数」等と呼ぶことになるので、察してほしい。

[[boolean-value-representation]]
=== 真偽値(boolean)
FBXフォーマットにおける真偽値は1バイトである。
しかし、その表現は若干奇妙である。

[[table__binary-representation-of-boolean-value]]
.真偽値のバイナリ表現
[option="header"]
|====
| 値    | 表現
| false | `'T'` (`0x54`)
| true  | `'Y'` (`0x59`)
|====

初見では「"true"と"Yes"かな？」などと誰もが思うに違いない^[要出典]^。
実際のところ `'T'` と `'Y'` が選ばれた経緯や理由は不明だが、
LSBを見て0ならfalse、1ならtrueとすれば実用上の問題はない。

[TIP]
.真偽値について過剰な仮定をするべきではない
Autodesk公式の製品やライブラリから出力されたと思わしきFBXファイルではすべて `'T'` と `'Y'` が使われているが、
Blender等のサードパーティのソフトウェアでは `0x0` と `0x1` を吐いている場合がある。
よって、むしろ入力が `'T'` か `'Y'` であると仮定すべきではないだろう。


[[structure-overall]]
== ファイル全体の構造
__Binary FBX__の全体は以下のような構造になっている。

[[table__structure-of-fbx-file-overall]]
.ファイル全体の構造
[options="header", cols="1,>1,2"]
|====
| 内容                  |            サイズ | 詳細
| マジックナンバー      |          21 bytes | `"Kaydara FBX Binary\x20\x20\x00"` (もちろん `\x20` は空白文字)。
| (詳細不明)            |           2 bytes | `[0x1a, 0x00]` 。意味は不明だが確認した全てのファイルでこのようになっていた。
| FBXバージョン         |           4 bytes
|
FBX 7.4では `7400` (リトルエンディアンなので、バイナリ表現では `[0xe8, 0x1c, 0x00, 0x00]` である)。
FBX 7.5では `7500` (バイナリでは `[0x4c, 0x1d, 0x00, 0x00]`)。
| トップレベルノード    |   (可変、0個以上) | 暗黙のルートノードの子ノード。 xref:node-structure[ノード] の0個以上の繰り返し。
| xref:node-null-record[__NULL-record__] | 13 or 25 bytes
|
詳細は xref:node-null-record[] を参照。
簡単に言えば、暗黙のルートノードの終了を示すマーカー。
内容はすべてのオクテットが `0x00` である。

FBX 7.4以前では13バイト、FBX 7.5以降では25バイトのサイズである。
| xref:file-footer-1[詳細不明なフッタ(1)]   |          16 bytes | 特殊な乱数か何かのように見える。 xref:file-footer-1[後述]。
| パディング            | (0〜15bytesで可変)    | 可変個の `0x00` 。16バイトアラインのためのものと思われる。
| 詳細不明なフッタ(2)   |         144 bytes
|
最初の4バイトは `0x00` 。
次の4バイトは、ヘッダでも登場したFBXバージョン(4バイト整数、リトルエンディアン)。
その次の120バイトは `0x00` 、
最後の16バイトは `[0xf8, 0x5a, 0x8c, 0x6a, 0xde, 0xf5, 0xd9, 0x7e, 0xec, 0xe9, 0x0c, 0xe3, 0x75, 0x8f, 0x29, 0x0b]` である。
この16バイトの内容の意味は不明。
|====

[[implicit-root-node]]
=== 暗黙のルートノード
ルートノードは、後述の xref:node-structure[__node record__] を持たない(そしてそれ故に暗黙である)。

ノード名と__node property__は__node record header__によって指定されるから、必然的にルートノードはこれらを持たない。
ルートノードは、ただ0個以上の子ノードのみを持つ。

[[file-footer-1]]
=== 詳細不明なフッタ(1)
16バイトのバイナリデータ。
詳細は不明。

筆者が幾つか観測してみたものを以下に列挙する。

.FBX7.4
----
fa bc ae 0a d7 ca d3 66 b6 75 f8 86 1a fe 2a 78
fa bc a8 0c d6 c0 dc 60 b7 7c f4 86 1f f7 26 78
fa bc a9 0b d0 c0 dd 67 b1 7c f4 86 1f f7 26 78
----

.FBX7.3
----
fa bc aa 0c d4 c0 dd 65 b1 78 f1 82 1a f3 23 7c
fa bc ab 0f d6 c0 dc 66 b3 78 f1 82 1a f3 23 7c
----

どのオクテットも上位4ビットが必ず固定であり、以下のような構造になっている。

----
fx bx ax 0x dx cx dx 6x bx 7x fx 8x 1x fx 2x 7x
----

完全な乱数というわけではないはずだが、アルゴリズムは不明。

エクスポータを実装するなら、現状では他のファイルのものをパクって使用するか、適当にそれっぽい乱数を生成して使うかのどちらかである。


[TIP]
.謎の16バイト
これと似たような「各オクテットの上位4ビットが固定の、乱数らしき16バイトのバイナリデータ」に、
__FBX Binary__にだけ存在するノードである link:../../structure#toplevel-fileid[`FileId` ノード]の最初の__node property__がある。

[[file-footer-padding]]
=== パディング
詳細不明はフッタ(2)は必ず16の倍数バイト目から始まるようである
(そしてフッタ(2)のサイズは144バイトであるから、真っ当な__FBX Binary__のサイズは必ず16の倍数になる。)
このパディングは、そのためのものである。

[NOTE]
.サードパーティの__FBX Binary__エクスポータ
たとえばblender-2.72bで使えるFBXエクスポートの機能(プラグイン？)は、正しくパディングを行わない。
__FBX Binary__の読み込みを実装するとき、フッタは正しく構成されていると仮定すべきではないだろう。
(むしろフッタには特に有益な情報が見出せないので、完全に無視してよいかもしれない。)

[[node-structure]]
== ノードの構造
以下では、ファイル中での、バイナリ表現されたノード全体のことを**ノードレコード**(__node record__)と呼ぶ
footnote:[この呼称は、 link:https://code.blender.org/2013/08/fbx-binary-file-format-specification/#node-record-format[FBX binary file format specification | Blender Code] (2015/12/31参照) を参考にしたもので、正式な名称ではない。]
。
ノードレコードは以下のような構造である。

[[table__structure-of-node-record]]
.ノードレコードの構造
[options="header", cols="4,>2,7"]
|====
| 内容                      |       サイズ  | 詳細
| 終端オフセット            |  4 or 8 bytes | このノードレコードの末尾のバイトの次のバイトの、ファイル先頭からの位置
| プロパティ数              |  4 or 8 bytes | このノードレコードの持つ__node property__の個数
| プロパティリストのバイト長 | 4 or 8 bytes | このノードレコードの__node property__のリスト全体が占めるバイトサイズ
| 名前のバイト長            |       1 bytes | ノード名のバイト長
| 名前                      |  (可変、必須) | ノード名
| プロパティリスト          | (可変、0個以上) | このノードレコードの__node property__のリスト(__node property__を順に並べるだけ)
| 子ノードのリスト          | (可変、0個以上) | 子ノードのノードレコードをただ並べたもの。子ノードは存在しないこともある
| xref:node-null-record[__NULL-record__] | (特定条件で存在、13 or 25 bytes) | FBX 7.4以下では13バイト、FBX 7.5以降では25バイトの `0x00` 。ノードレコードの終了を示している。特定条件でのみ存在する。
|====

最初の3要素は、**FBX 7.4以下では4バイト、FBX 7.5以降では8バイトである。

[NOTE]
.暗黙のルートノード
暗黙のルートノードだけは、この構造を持たない。

[[node-null-record]]
=== __NULL-record__
ノードレコードを読むうえで、必ず読むべき固定長の情報は、最初の13バイトである
(これはノードレコードのヘッダとして考えることもできる)。
そして、この13バイト全てを `0x00` としたデータを、ノードレコードの終端を示す情報として用いることがある。
これを__NULL-record__と呼ぶことにする。

__NULL-record__は全てのノードレコード末尾に現れるわけではなく、以下の少なくとも一方を満たすノードレコードの末尾のみに存在する。

- 子ノードが1つ以上存在する
- __node property__を持たない

むしろ「子ノードを持たず、かつ__node property__を1つ以上持つようなノードのノードレコード末尾でのみ、__NULL-record__が省略される」
とでも表現した方がわかりやすいかもしれない。

[NOTE]
.暗黙のルートノードの__NULL-record__
====
暗黙のルートノードも(常識的なFBXファイルでは)子ノードを1つ以上持つので、__NULL-record__が存在するということも自然に判断できる。
なお、暗黙のルートノード以外のノードを一切持たないようなFBXファイル(当然、3Dコンテンツとしては無効である)において、
__NULL-record__の省略が許されるかは不明である。

というかそんなファイル公式で作られようがないだろうから、知りようがない。

====

[TIP]
.__NULL-record__からわかること
====
__NULL-record__の存在によって、
**一度終端オフセットを利用してノードレコードの終了位置だと判断された場所は、さらに親のノードレコードの終了位置ではありえない**ことがわかる。

別の表現をすれば、**ひとつの箇所で2つ以上のノードレコードが終了することはない**。

====


[[node-property]]
== __Node propety__
ノードレコードの場合と同様に、ひとつの__node property__全体のバイナリ表現を**プロパティレコード**(__node property record__)と呼ぶ
footnote:[この場合、構文としての__node property__に注目していることは明らかなので、「ノードプロパティレコード」のような冗長な名称は使わないことにする。]
ことにしよう。

プロパティレコードは以下のような構造である。

[[table__structure-of-property-record]]
.プロパティレコードの構造
[options="header", cols="2,>3,7"]
|====
| 内容      |       サイズ  | 詳細
| 型コード  |        1 byte | データの link:index.html#types-of-node-property[型] をASCIIコード1文字で示す。
| データ    | (型に応じたサイズ) | 型コードで示された型のデータ(必要なら追加のヘッダも)を持つ。リトルエンディアン。詳しくは下記参照。
|====

型コードは1バイトのASCII文字であり、以下のような割り当てである。

[[table__type-code-of-node-property]]
.型コード
[options="header", cols="2,>3,3,7"]
|====
| 型コード  | 種類          | この文書中での呼称 footnote:[個人的な理由で、Rustでの型名を使うことにする。] | 型
| `'C'`     | プリミティブ  | `bool`                | 1ビット論理値
| `'Y'`     | プリミティブ  | `i16`                 | 2バイト符号付き整数
| `'I'`     | プリミティブ  | `i32`                 | 4バイト符号付き整数
| `'L'`     | プリミティブ  | `i64`                 | 8バイト符号付き整数
| `'F'`     | プリミティブ  | `f32`                 | 4バイト単精度浮動小数点数 (IEEE 754)
| `'D'`     | プリミティブ  | `f64`                 | 8バイト単精度浮動小数点数 (IEEE 754)
| `'b'`     | 配列          | `[bool]`              | 1ビット論理値の配列
| `'i'`     | 配列          | `[i32]`               | 4バイト符号付き整数の配列
| `'l'`     | 配列          | `[i64]`               | 8バイト符号付き整数の配列
| `'f'`     | 配列          | `[f32]`               | 4バイト単精度浮動小数点数 (IEEE 754) の配列
| `'d'`     | 配列          | `[f64]`               | 8バイト単精度浮動小数点数 (IEEE 754) の配列
| `'S'`     | 特殊          | `String`              | 文字列
| `'R'`     | 特殊          | `[u8]`                | バイナリデータ (raw binary data)
|====

プリミティブ型では、データが型コードの直後にそのまま配置されるが、
配列型と特殊型では、それぞれ更に追加のヘッダを持ち、その後にデータがくる。

[[table__structure-of-array-type-of-property-value]]
.配列型のデータ部の構造
[options="header", cols="2,>3,7"]
|====
| 内容              |    サイズ | 詳細
| 配列の要素数      |   4 bytes | 配列の要素数。
| エンコーディング  |   4 bytes
| エンコーディング方式。
`0` であれば非圧縮。
`1` であれば、zlib形式(zlibヘッダあり)で圧縮されたデータ。
今のところ `0` と `1` 以外の値は観測されていないらしい
footnote:[link:https://code.blender.org/2013/08/fbx-binary-file-format-specification/#property-record-format[FBX binary file format specification \| Blender Code], 2015/12/31参照]
。
| データのバイト長  |   4 bytes
| (ヘッダ等を除いた)データ本体がファイル中で占めるバイトサイズ。圧縮されていれば圧縮後データのバイトサイズ。非圧縮の場合は要素数×要素サイズ。
| データ            | (指定されたサイズ) | 型コードで示された型のデータを、指定されたエンコーディングで、指定された個数または長さ分持つ。
|====

[[table__structure-of-special-type-of-property-value]]
.特殊型(文字列、バイナリ)のデータ部の構造
[options="header", cols="2,>3,7"]
|====
| 内容      | サイズ    | 詳細
| バイト長  |   4 bytes | データのバイト長。
| データ    |  (可変長) | 指定されたバイト長のデータ。文字列であってもNUL終端でなく、 `\x00` や `\x01` を含み得る。
|====

文字列は(筆者の観測した範囲では)ASCII文字列であった。

[[special-characters-in-string-type-of-node-property]]
=== 文字列型の__node property__で `\x00` 等が使われる場合
たとえば `Object` の子ノードの `Geometry` ノード等は、2番目の__node property__として文字列型で `"\x00\x01Geometry"` で終わるものを保持することがある。
これは、このノードを3Dコンテンツにおける特定の情報として解釈する際に、名前空間を表現するものである。
具体的には、__ASCII FBX__で `"Namespace::Name"` と表現されるものが、__Binary FBX__では `"Name\x00\x01Namespace"` のように保持される。

[NOTE]
.文字列の分解
筆者は link:++http://help.autodesk.com/view/FBX/2016/ENU/?guid=__cpp_ref_class_fbx_object_html++[Help: FbxObject Class Reference]
での `FbxObject::GetNamespacePrefix()` 等で取得できる情報がこの名前空間なのではないかと考えているが、検証していないので詳細は不明。

[[escape-in-string-type-of-property-value]]
=== 文字列型でのエスケープ
エスケープが行われる文字が、3種類だけある。

[[table__characters-to-escaped-in-string-property]]
.エスケープが行われる文字
[options="header", cols="1,1"]
|====
| 元の文字  | エスケープ後の文字
| `"`       | `&amp;quot;`
| `\n`      | `&amp;lf;`
| `\r`      | `&amp;cr;`
|====

これはまったくもって驚くべきことだが、HTML/XML風なエスケープをする割に **`&amp;` はエスケープされない**。
すなわち、元データ中の `"` も `&amp;quot;` も、FBXへ出力後は区別なく `&amp;quot;` に変換されてしまい、区別が付かなくなるのである。
到底まともな仕様ではないが、仕方ない。仕様なのだ。
